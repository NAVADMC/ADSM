from django.db import models
from ScenarioCreator.models import ProductionType, Zone, Unit
import re

"""Results models explanation: The Results models are containers to capture all of the output generated by the CEngine
simulation and present it to the user broken down into 13 different tables.

Model Declarations: Each model creates a table in sqlite3 and a 'model' for table presentation on the GUI.  So
 each model serves double duty.  Notice that there are effectively 3 names for each field inside a model.
 1) the Python name (e.g. tsdASusc = models.) is used when constructing the object and is designed to match the CEngine output.
 2) the db_column name will show up when a user exports the DataBase.  They are at least readable explanations.
 3) verbose_name is used in the GUI for displaying Table headers.  Without this, Django would use the Python name,
 which is significantly more obscure.
 The code in scripts/Output_Table.py (.ipynb) was used to generate these name declarations.  Also, if you're reading this
 doc and you don't know about IPython Notebooks, go get IPython Notebooks."""


def printable_name(underscores_name):
    spaced = re.sub(r'_', r' ', underscores_name)
    return spaced.title()  # capitalize


class OutputBaseModel(models.Model):
    def iter(self):
        for i in self._meta.get_all_field_names():
            yield (i, getattr(self, i))
    # This lets; you; do:
    # for field, val in myModel:
    #     print( field, val)


class OutputManager(models.Manager):
    def bulk_create(self, header_line, cmd_strings, *args, **kwargs):
        headers = header_line.split(',')
        report_objects = []
        for cmd_string in cmd_strings:
            sparse_values = {}
            values = cmd_string.split(',')
            pairs = zip(headers, values)
            for key, value in pairs:
                if value and value != '0':
                    sparse_values[key] = int(value)
            report_objects.append(DailyReport(sparse_dict=str(sparse_values), full_line=cmd_string))

        # for obj in report_objects:
        #     print(obj)  #.save()
        return super().bulk_create(report_objects)


class DailyReport(OutputBaseModel):
    sparse_dict = models.TextField()
    full_line = models.TextField()
    # to get the dictionary object back:
    # import ast
    # ast.literal_eval("{'muffin' : 'lolz', 'foo' : 'kitty'}")

    objects = OutputManager()

    def __str__(self):
        return self.sparse_dict


class SpreadGroup(OutputBaseModel):
    UAll = models.IntegerField(blank=True, null=True, verbose_name="Unit All Spread Types")
    UDir = models.IntegerField(blank=True, null=True, verbose_name="Unit Direct")
    UInd = models.IntegerField(blank=True, null=True, verbose_name="Unit Indirect")
    UAir = models.IntegerField(blank=True, null=True, verbose_name="Unit Air")

    AAll = models.IntegerField(blank=True, null=True, verbose_name="Animal All Spread Types")
    ADir = models.IntegerField(blank=True, null=True, verbose_name="Animal Direct")
    AInd = models.IntegerField(blank=True, null=True, verbose_name="Animal Indirect")
    AAir = models.IntegerField(blank=True, null=True, verbose_name="Animal Air")
    # TODO: Not storing cumulative at the moment, since it can be computed


class DetectionBracketGroup(object):
    blank = models.IntegerField(blank=True, null=True, verbose_name="either method")  # 'blank' should be a special case in the parser
    Clin = models.IntegerField(blank=True, null=True, verbose_name="Detection from Clinical signs")
    Test = models.IntegerField(blank=True, null=True, verbose_name="Detection from Lab Tests")
    # TODO: Not storing cumulative at the moment, since it can be computed


class DetectionGroup(object):
    UAll = models.IntegerField(blank=True, null=True, verbose_name="Units from Either method")
    UClin = models.IntegerField(blank=True, null=True, verbose_name="Units from Clinical signs")
    UTest = models.IntegerField(blank=True, null=True, verbose_name="Units from Lab Tests")

    AAll = models.IntegerField(blank=True, null=True, verbose_name="Animals from Either method")
    AClin = models.IntegerField(blank=True, null=True, verbose_name="Animals from Clinical signs")
    ATest = models.IntegerField(blank=True, null=True, verbose_name="Animals from Lab Tests")


class TraceGroup(object):
    UAll = models.IntegerField(blank=True, null=True, verbose_name="Units from Either method ")
    UAllp = models.IntegerField(blank=True, null=True, verbose_name="Units from Either method Possible")
    UDir = models.IntegerField(blank=True, null=True, verbose_name="Units Direct Spread ")
    UDirp = models.IntegerField(blank=True, null=True, verbose_name="Units Direct Spread Possible")
    UInd = models.IntegerField(blank=True, null=True, verbose_name="Units Indirect Spread ")
    UIndp = models.IntegerField(blank=True, null=True, verbose_name="Units Indirect Spread Possible")

    AAll = models.IntegerField(blank=True, null=True, verbose_name="Animals from Either method ")
    AAllp = models.IntegerField(blank=True, null=True, verbose_name="Animals from Either method Possible")
    ADir = models.IntegerField(blank=True, null=True, verbose_name="Animals Direct Spread ")
    ADirp = models.IntegerField(blank=True, null=True, verbose_name="Animals Direct Spread Possible")
    AInd = models.IntegerField(blank=True, null=True, verbose_name="Animals Indirect Spread ")
    AIndp = models.IntegerField(blank=True, null=True, verbose_name="Animals Indirect Spread Possible")


class TestTriggerGroup(object):
    UAll = models.IntegerField(blank=True, null=True, verbose_name="Units from Any Cause")
    URing = models.IntegerField(blank=True, null=True, verbose_name="Units because of Ring")
    UDirFwd = models.IntegerField(blank=True, null=True, verbose_name="Units because of Direct Forward trace")
    UIndFwd = models.IntegerField(blank=True, null=True, verbose_name="Units because of Indirect Forward trace")
    UDirBack = models.IntegerField(blank=True, null=True, verbose_name="Units because of Direct Back trace")
    UIndBack = models.IntegerField(blank=True, null=True, verbose_name="Units because of Indirect Back trace")
    UDet = models.IntegerField(blank=True, null=True, verbose_name="Units ")

    AAll = models.IntegerField(blank=True, null=True, verbose_name="Animals from Any Cause")
    ARing = models.IntegerField(blank=True, null=True, verbose_name="Animals because of Ring")
    ADirFwd = models.IntegerField(blank=True, null=True, verbose_name="Animals because of Direct Forward trace")
    AIndFwd = models.IntegerField(blank=True, null=True, verbose_name="Animals because of Indirect Forward trace")
    ADirBack = models.IntegerField(blank=True, null=True, verbose_name="Animals because of Direct Back trace")
    AIndBack = models.IntegerField(blank=True, null=True, verbose_name="Animals because of Indirect Back trace")
    ADet = models.IntegerField(blank=True, null=True, verbose_name="Animals ")


class TestOutcomeGroup(object):
    UTruePos = models.IntegerField(blank=True, null=True, verbose_name="Units True Positives")
    UFalsePos = models.IntegerField(blank=True, null=True, verbose_name="Units False Positives")
    UTrueNeg = models.IntegerField(blank=True, null=True, verbose_name="Units True Negatives")
    UFalseNeg = models.IntegerField(blank=True, null=True, verbose_name="Units False Negatives")


class DailyByProductionType(OutputBaseModel):
    iteration = models.IntegerField(blank=True, null=True, db_column='iteration', verbose_name=printable_name('iteration'),
        help_text='The iteration during which the outputs in this records where generated.', )
    production_type = models.ForeignKey(ProductionType,
        help_text='The identifier of the production type that these outputs apply to.', )
    exp = models.ForeignKey(SpreadGroup, blank=True, null=True, verbose_name="Exposures")
    inf = models.ForeignKey(SpreadGroup, blank=True, null=True, verbose_name="Infections")
    firstDetection = models.ForeignKey(DetectionBracketGroup, blank=True, null=True, verbose_name="First Detection")
    lastDetection = models.ForeignKey(DetectionBracketGroup, blank=True, null=True, verbose_name="Last Detection")
    det = models.ForeignKey(DetectionGroup, blank=True, null=True, verbose_name="Detections")
    tr = models.ForeignKey(TraceGroup, blank=True, null=True, verbose_name="Traces")
    exm = models.ForeignKey(TestTriggerGroup, blank=True, null=True, verbose_name="Examinations")
    #tstcU uses the TestTriggerGroup because of the overlap in Directional causes
    tstcU = models.ForeignKey(TestTriggerGroup, blank=True, null=True, verbose_name="Lab Test Triggers")
    #we need a second model to catch True/False Pos/Neg results
    tst = models.ForeignKey(TestOutcomeGroup, blank=True, null=True, verbose_name="Lab Test Outcomes")



class DailyByZoneAndProductionType(OutputBaseModel):
    filler = models.IntegerField(blank=True, null=True, )


class DailyByZone(OutputBaseModel):
    filler = models.IntegerField(blank=True, null=True, )


class DailyControls(OutputBaseModel):
    filler = models.IntegerField(blank=True, null=True, )


class Iteration(OutputBaseModel):
    headers = models.TextField()

